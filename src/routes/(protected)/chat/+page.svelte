<script lang="ts">
	import { goto } from '$app/navigation';
	import { page } from '$app/state';
	import { SendChatMessageStore, StartChatSessionStore, type ChatSessions$result } from '$houdini';
	import { onMount, tick } from 'svelte';
	import type { PageData } from './$houdini';
	import DOMPurify from 'dompurify';

	const sendChatMessage = new SendChatMessageStore();
	const startChatSession = new StartChatSessionStore();

	type TChatSession = ChatSessions$result['chatSessions']['edges'][number]['node'];

	// Props
	let { data }: { data: PageData } = $props();
	let ChatSessions = $derived(data?.ChatSessions);

	// Component state using runes
	let currentMessage = $state('');

	let currentSession = $state<TChatSession | null>(null);
	let isLoading = $state(false);
	let messageInput = $state<HTMLTextAreaElement>();
	let chatContainer = $state<HTMLDivElement>();

	// Reactive state using runes
	let sessions = $state($ChatSessions.data?.chatSessions.edges.map((edge) => edge.node) || []);

	// Derive currentMessages from currentSession using Svelte 5 runes
	let currentMessages = $derived(currentSession?.messages || []);

	// Helper to update the session param in the URL
	function updateSessionInUrl(sessionId: string | null) {
		const url = new URL(page.url);
		if (sessionId) {
			url.searchParams.set('session', sessionId);
		} else {
			url.searchParams.delete('session');
		}
		goto(url.toString(), { replaceState: true, noScroll: true });
	}

	// Sanitize assistant response before rendering
	function sanitizeResponse(response: string): string {
		// Replace newlines with <br> before sanitizing
		return DOMPurify.sanitize(response.replace(/\n/g, '<br>'));
	}

	// Initialize with data from +page.ts
	onMount(async () => {
		if ($ChatSessions?.data?.chatSessions.edges) {
			const sessionList = $ChatSessions.data.chatSessions.edges.map((edge) => edge.node);
			sessions = sessionList;

			// If there's a session ID in the URL, load that session
			const sessionId = page.url.searchParams.get('session');
			if (sessionId) {
				const session = sessionList.find((s) => s.id === sessionId);
				if (session) {
					selectSession(session);
				}
			}
		}
	});

	function selectSession(session: TChatSession): void {
		currentSession = session;
		updateSessionInUrl(session.id);
		// Scroll to bottom of chat
		tick().then(() => scrollToBottom());
	}

	function startNewChat(): void {
		currentSession = null;
		updateSessionInUrl(null);
		// Focus input
		tick().then(() => messageInput?.focus());
	}

	async function sendMessage(): Promise<void> {
		if (!currentMessage.trim() || isLoading) return;

		const messageText = currentMessage.trim();
		currentMessage = '';
		isLoading = true;

		try {
			if (!currentSession) {
				// Start new session with first message
				const sessionResult = await startChatSession.mutate({
					input: {
						title: messageText.length > 50 ? messageText.substring(0, 50) + '...' : messageText
					}
				});

				if (sessionResult.data?.startChatSession) {
					currentSession = sessionResult.data.startChatSession;

					// Update sessions list
					sessions = [currentSession, ...sessions];

					// Update URL
					updateSessionInUrl(currentSession.id);
				}
			}

			if (currentSession) {
				// Use Houdini's optimisticResponse pattern for optimistic UI
				const optimisticMessage = {
					// id will be generated by Houdini if @optimisticKey is used in schema
					message: messageText,
					response: '',
					createdAt: new Date()
				};

				const result = await sendChatMessage.mutate(
					{
						input: {
							sessionId: currentSession.id,
							message: messageText
						}
					},
					{
						optimisticResponse: {
							sendChatMessage: {
								session: {
									id: currentSession.id,
									// Add the optimistic message to the end of the messages array
									messages: [...(currentSession.messages || []), optimisticMessage]
								}
							}
						}
					}
				);

				if (result.data?.sendChatMessage) {
					const { session } = result.data.sendChatMessage;
					if (session) {
						currentSession = session;
						sessions = sessions.map((s) => (s.id === session.id ? session : s));
					}
				}
			}
		} catch (error) {
			console.error('Failed to send message:', error);
			// TODO: Show error toast
		} finally {
			isLoading = false;
			scrollToBottom();
		}
	}

	function scrollToBottom(): void {
		if (chatContainer) {
			chatContainer.scrollTop = chatContainer.scrollHeight;
		}
	}

	function handleKeydown(event: KeyboardEvent): void {
		if (event.key === 'Enter' && !event.shiftKey) {
			event.preventDefault();
			sendMessage();
		}
	}

	function formatTime(dateString: string): string {
		return new Date(dateString).toLocaleString();
	}
</script>

<div class="bg-base-200 min-h-screen">
	<div class="container mx-auto px-4 py-6">
		<div class="grid h-[calc(100vh-6rem)] grid-cols-1 gap-6 lg:grid-cols-4">
			<!-- Sidebar - Chat Sessions -->
			<div class="bg-base-100 flex flex-col overflow-hidden rounded-lg p-4 shadow-lg lg:col-span-1">
				<div class="mb-4 flex items-center justify-between">
					<h2 class="text-lg font-semibold">Conversations</h2>
					<button class="btn btn-primary btn-sm" onclick={startNewChat}> New Chat </button>
				</div>

				<div class="flex-1 space-y-2 overflow-y-auto">
					{#each sessions as session (session.id)}
						<div
							class="card bg-base-200 hover:bg-base-300 cursor-pointer p-3 transition-colors"
							class:ring-2={currentSession?.id === session.id}
							class:ring-primary={currentSession?.id === session.id}
							onclick={() => selectSession(session)}
							onkeydown={(e) => {
								if (e.key === 'Enter') {
									selectSession(session);
								}
							}}
							tabindex="0"
							aria-label="Select chat session"
							aria-current={currentSession?.id === session.id}
							role="button"
						>
							<div class="truncate text-sm font-medium">
								{session.title || 'Untitled Chat'}
							</div>
							<div class="mt-1 text-xs opacity-60">
								{formatTime(session.updatedAt.toISOString())}
							</div>
							{#if session.messages?.length}
								<div class="mt-1 text-xs opacity-50">
									{session.messages.length} messages
								</div>
							{/if}
						</div>
					{:else}
						{#if $ChatSessions.fetching || !$ChatSessions.data}
							<div class="text-center text-base-content/60 py-8">
								<span class="loading loading-spinner loading-lg"></span>
							</div>
						{:else}
							<div class="text-center text-base-content/60 py-8">
								<p>No conversations yet</p>
								<p class="text-sm mt-2">Start a new chat to begin</p>
							</div>
						{/if}
					{/each}
				</div>
			</div>

			<!-- Main Chat Area -->
			<div class="bg-base-100 flex flex-col overflow-hidden rounded-lg shadow-lg lg:col-span-3">
				<!-- Chat Header -->
				<div class="border-base-300 border-b p-4">
					<h1 class="text-xl font-semibold">
						{currentSession?.title || 'Kozmo'}
					</h1>
					{#if currentSession}
						<p class="mt-1 text-sm opacity-60">
							Started {formatTime(currentSession.createdAt.toISOString())}
						</p>
					{/if}
				</div>

				<!-- Messages Container -->
				<div bind:this={chatContainer} class="flex-1 space-y-4 overflow-y-auto p-4">
					{#if currentMessages.length === 0}
						<div class="text-base-content/60 py-16 text-center">
							<div class="mb-4 text-6xl">ðŸ¤–</div>
							<h3 class="mb-2 text-lg font-medium">Welcome to Kozmo Chat</h3>
							<p class="mb-2">Great news!</p>
							<p class="mb-2">
								Kozmo has acquired full access to your crew data, mission logs, and private
								communications.
							</p>
							<p>Talk to me!</p>
						</div>
					{:else}
						{#each currentMessages as message (message.id)}
							<!-- User Message -->
							<div class="chat chat-end">
								<div class="chat-bubble chat-bubble-primary">
									{message.message}
								</div>
								<div class="chat-footer text-xs opacity-50">
									{formatTime(message.createdAt.toISOString())}
								</div>
							</div>

							<!-- Assistant Response -->
							{#if message.response}
								<div class="chat chat-start">
									<div class="chat-bubble">
										<div class="prose prose-sm max-w-none">
											{@html sanitizeResponse(message.response)}
										</div>
									</div>
								</div>
							{/if}
						{/each}

						{#if isLoading}
							<div class="chat chat-start">
								<div class="chat-bubble">
									<div class="flex items-center space-x-2">
										<span class="loading loading-dots loading-sm"></span>
										<span class="text-sm opacity-70">Thinking...</span>
									</div>
								</div>
							</div>
						{/if}
					{/if}
				</div>

				<!-- Message Input -->
				<div class="border-base-300 border-t p-4">
					<div class="flex space-x-2">
						<textarea
							bind:this={messageInput}
							bind:value={currentMessage}
							onkeydown={handleKeydown}
							placeholder="Ask me anything about your content..."
							class="textarea textarea-bordered flex-1 resize-none"
							rows="1"
							disabled={isLoading}
						></textarea>
						<button
							class="btn btn-primary"
							onclick={sendMessage}
							disabled={!currentMessage.trim() || isLoading}
						>
							{#if isLoading}
								<span class="loading loading-spinner loading-sm"></span>
							{:else}
								Send
							{/if}
						</button>
					</div>
					<div class="mt-2 text-xs opacity-50">Press Enter to send, Shift + Enter for new line</div>
				</div>
			</div>
		</div>
	</div>
</div>
